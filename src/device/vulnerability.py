import csv
from collections import defaultdict
import re
from libs.check import has_additional_data, is_global_unicast_ipv6, is_valid_ipv4, is_valid_ipv6, check_ipv6_addresses_generated_from_prefix, is_ipv6_predictable, is_link_local_ipv6
from libs.convert import convert_preferenceRA
from src.create_csv import sort_and_deduplicate_vul_csv
from src.interface import Interface
from src.send import IPMode
import os
import ipaddress

file_path = "src/tmp/"

class Vulnerability:
    def __init__(self, interface:str, prefix_len:int, network:str, smac:str, rpref:int, dns:list[str], role_file=f"{file_path}role_node.csv", time_incoming_file=f"{file_path}time_incoming.csv", vulnerability_file=f"{file_path}vulnerability.csv"):
        self.role_file = role_file
        self.time_incoming_file = time_incoming_file
        self.vulnerability_file = vulnerability_file
        self.interface = interface
        self.prefix_len = prefix_len
        self.network = network
        self.smac = smac
        self.pref = convert_preferenceRA(rpref)
        self.dns = dns

    @staticmethod
    def read_role_node_csv(filename=f"{file_path}role_node.csv"):
        """Return the dictionary of sorted devices with their corresponding MAC"""
        result = {}
        if not has_additional_data(filename):
            return
        with open(filename, newline='') as csvfile:
            reader = csv.DictReader(csvfile)
            for row in reader:
                try:
                    device_number = int(row['Device_Number'].strip())
                    mac = row['MAC'].strip()
                    result[device_number] = mac
                except (ValueError, KeyError):
                    continue
        return dict(sorted(result.items()))

    def handle_vulnerabilities(self, mode:str, ipver:IPMode):
        """Main entry to handle all vulnerabilities. Output: None. Description: Orchestrates vulnerability checks and writes results to CSV."""
        if mode == "802.1x":
            self.store_eap_vulnerability()
        if mode in ['p', 'a', 'a+']:
            self.store_MDNS_vulnerability(ipver=ipver)
            self.store_llmnr_vulnerability(ipver=ipver)
            self.store_ws_vulnerability(ipver=ipver)
            self.store_dnssd_vulnerability(ipver=ipver)
            self.store_icmp_vulnerability(ipver=ipver)
            if ipver.ipv6:
                self.store_mld_vulnerability()
                self.store_ipv6_vulnerability()
            if ipver.ipv4:
                pass
        if mode == "a+":
            if ipver.ipv6:
                self.store_ra_vulnerability()
                
        self.fill_missing_vulnerabilities(mode, ipver)
        sort_and_deduplicate_vul_csv(self.vulnerability_file)

    def fill_missing_vulnerabilities(
        self,
        mode: str,
        ipver: IPMode,
        defined_vuln_file: str = "docs/list_defined_vulnerability.csv"
    ):
        """
        Fill missing vulnerabilities in vulnerability.csv with Label=2 (N/A) based on defined vulnerabilities.
        
        Args:
            mode (str): Scan mode (e.g., 'p', 'a', 'a+', '802.1x')
            ipver (IPMode): IPMode object with ipv4 and ipv6 boolean attributes
            defined_vuln_file (str): Path to list of defined vulnerabilities
        """
        
        # Active IP version values allowed in this run
        if ipver.ipv4 and ipver.ipv6:
            active_ipvers = {'4', '6', 'both'}
        elif ipver.ipv4:
            active_ipvers = {'4', 'both'}
        elif ipver.ipv6:
            active_ipvers = {'6', 'both'}
        else:
            return

        # Load defined vulnerabilities
        defined = {'Node': [], 'Network': []}
        try:
            with open(defined_vuln_file, newline='', encoding='utf-8') as f:
                reader = csv.DictReader(f)
                for row in reader:
                    raw_mode = row['Mode'].strip()
                    allowed_modes = [m.strip() for m in raw_mode.split(',') if m.strip()]
                    # Exact mode membership (avoid substring match like 'a' in 'a+')
                    if mode in allowed_modes and row['IPver'].strip() in active_ipvers:
                        entry = {
                            'ID_Type': row['ID'].strip(),
                            'Mode': raw_mode,          # keep original string
                            'IPver': row['IPver'].strip(),
                            'Code': row['Code'].strip(),
                            'Description': row['Description'].strip()
                        }
                        if entry['ID_Type'] == 'Node':
                            defined['Node'].append(entry)
                        elif entry['ID_Type'] == 'Network':
                            defined['Network'].append(entry)
        except FileNotFoundError:
            return

        # Devices (Node entries)
        devices = Vulnerability.read_role_node_csv(self.role_file)
        if not isinstance(devices, dict):
            devices = {}

        # Existing vulnerability rows indexed by (ID, MAC, IPver, Code) -> Label
        existing = {}
        if os.path.exists(self.vulnerability_file):
            try:
                with open(self.vulnerability_file, newline='', encoding='utf-8') as f:
                    reader = csv.DictReader(f)
                    for row in reader:
                        key = (
                            row['ID'].strip(),
                            row['MAC'].strip(),
                            row['IPver'].strip(),
                            row['Code'].strip()
                        )
                        existing[key] = row['Label'].strip()
            except Exception:
                pass

        new_rows = []

        # Node vulnerabilities: create one row per device if missing (no Label 0/1)
        for v in defined['Node']:
            for device_id, mac in devices.items():
                key = (str(device_id), mac, v['IPver'], v['Code'])
                label_existing = existing.get(key)
                if label_existing in ('0', '1'):
                    continue  # Already present with a concrete result
                if label_existing == '2':
                    continue  # Already marked N/A
                # Add N/A row
                new_rows.append({
                    'ID': str(device_id),
                    'MAC': mac,
                    'Mode': v['Mode'],
                    'IPver': v['IPver'],
                    'Code': v['Code'],
                    'Description': v['Description'],
                    'Label': '2'
                })
                existing[key] = '2'

        # Network vulnerabilities: single entry (ID='Network', MAC='')
        for v in defined['Network']:
            key = ('Network', '', v['IPver'], v['Code'])
            label_existing = existing.get(key)
            if label_existing in ('0', '1'):
                continue
            if label_existing == '2':
                continue
            new_rows.append({
                'ID': 'Network',
                'MAC': '',
                'Mode': v['Mode'],
                'IPver': v['IPver'],
                'Code': v['Code'],
                'Description': v['Description'],
                'Label': '2'
            })
            existing[key] = '2'

        if new_rows:
            try:
                os.makedirs(os.path.dirname(self.vulnerability_file), exist_ok=True)
                write_header = not os.path.exists(self.vulnerability_file)
                with open(self.vulnerability_file, mode='a', newline='', encoding='utf-8') as f:
                    fieldnames = ['ID', 'MAC', 'Mode', 'IPver', 'Code', 'Description', 'Label']
                    writer = csv.DictWriter(f, fieldnames=fieldnames)
                    if write_header:
                        writer.writeheader()
                    writer.writerows(new_rows)
            except Exception:
                return
            
    def store_eap_vulnerability(self, eap_file=f"{file_path}eap.csv"):
        """Output: Writes EAP vulnerability to CSV. Description: Checks for 802.1x deployment and stores result."""
        detect_eap = has_additional_data(eap_file)
        existing_rows = set()
        output_file = self.vulnerability_file
        if os.path.exists(output_file):
            with open(output_file, 'r') as file:
                reader = csv.reader(file)
                next(reader, None)
                for row in reader:
                    if len(row) == 7:
                        row_tuple = tuple(cell.strip() for cell in row[:7])
                        existing_rows.add(row_tuple)
        new_rows = []
        network_row = ('Network', '', '802.1x', '', 'PTV-NET-NET-MISCONF-8021X', 'Network does not have 802.1x deployed', '0' if detect_eap else '1')
        if network_row not in existing_rows:
            new_rows.append({
                'ID': network_row[0],
                'MAC': network_row[1],
                'Mode': network_row[2],
                'IPver': network_row[3],
                'Code': network_row[4],
                'Description': network_row[5],
                'Label': network_row[6]
            })
        if new_rows:
            os.makedirs(os.path.dirname(output_file), exist_ok=True)
            write_header = not os.path.exists(output_file)
            with open(output_file, mode='a', newline='') as csvfile:
                fieldnames = ['ID', 'MAC', 'Mode', 'IPver', 'Code', 'Description', 'Label']
                writer = csv.DictWriter(csvfile, fieldnames=fieldnames)
                if write_header:
                    writer.writeheader()
                writer.writerows(new_rows)

    def store_MDNS_vulnerability(self, MDNS_file=f"{file_path}MDNS.csv", ipver=IPMode(True, True)):
        """Output: Writes MDNS vulnerability to CSV. Description: Checks for MDNS responses and stores device/network results."""
        role_dict = Vulnerability.read_role_node_csv(self.role_file)
        if not isinstance(role_dict, dict) or not role_dict:
            return
        MDNS_has_data = has_additional_data(MDNS_file)
        if ipver.ipv4 and ipver.ipv6:
            ipver_value = 'both'
        elif ipver.ipv4:
            ipver_value = '4'
        elif ipver.ipv6:
            ipver_value = '6'
        else:
            return
        mdns_macs = set()
        if MDNS_has_data:
            try:
                with open(MDNS_file, newline='') as csvfile:
                    reader = csv.DictReader(csvfile)
                    for row in reader:
                        mac = row['MAC'].strip()
                        mdns_macs.add(mac)
            except FileNotFoundError:
                return
        existing_rows = set()
        output_file = self.vulnerability_file
        if os.path.exists(output_file):
            with open(output_file, newline='') as csvfile:
                reader = csv.DictReader(csvfile)
                for row in reader:
                    row_tuple = tuple(row[field].strip() for field in ['ID', 'MAC', 'Mode', 'IPver', 'Code', 'Description', 'Label'])
                    existing_rows.add(row_tuple)
        new_rows = []
        at_least_one_detected = False
        for device_id, mac in role_dict.items():
            label = '1' if mac in mdns_macs else '0'
            if label == '1':
                at_least_one_detected = True
            row = (str(device_id), mac, 'p,a,a+', ipver_value, 'PTV-NET-IDENT-MDNS-PTRDEV', 'Device responds to MDNS packets', label)
            if row not in existing_rows:
                new_rows.append(dict(zip(['ID', 'MAC', 'Mode', 'IPver', 'Code', 'Description', 'Label'], row)))
                existing_rows.add(row)
        network_label = '1' if at_least_one_detected else '0'
        network_row = ('Network', '', 'p,a,a+', ipver_value, 'PTV-NET-IDENT-MDNS-PTR', 'Network allows the delivery of MDNS packets', network_label)
        if network_row not in existing_rows:
            new_rows.append(dict(zip(['ID', 'MAC', 'Mode', 'IPver', 'Code', 'Description', 'Label'], network_row)))
        if new_rows:
            os.makedirs(os.path.dirname(output_file), exist_ok=True)
            write_header = not os.path.exists(output_file)
            with open(output_file, mode='a', newline='') as csvfile:
                fieldnames = ['ID', 'MAC', 'Mode', 'IPver', 'Code', 'Description', 'Label']
                writer = csv.DictWriter(csvfile, fieldnames=fieldnames)
                if write_header:
                    writer.writeheader()
                writer.writerows(new_rows)

    def store_llmnr_vulnerability(self, llmnr_file=f"{file_path}LLMNR.csv", ipver=IPMode(True, True)):
        """Output: Writes LLMNR vulnerability to CSV. Description: Checks for LLMNR responses and stores device/network results."""
        role_dict = Vulnerability.read_role_node_csv(self.role_file)
        if not isinstance(role_dict, dict) or not role_dict:
            return
        llmnr_has_data = has_additional_data(llmnr_file)
        if ipver.ipv4 and ipver.ipv6:
            ipver_value = 'both'
        elif ipver.ipv4:
            ipver_value = '4'
        elif ipver.ipv6:
            ipver_value = '6'
        else:
            return
        llmnr_macs = set()
        if llmnr_has_data:
            try:
                with open(llmnr_file, newline='') as csvfile:
                    reader = csv.DictReader(csvfile)
                    for row in reader:
                        mac = row['MAC'].strip()
                        llmnr_macs.add(mac)
            except FileNotFoundError:
                return
        existing_rows = set()
        output_file = self.vulnerability_file
        if os.path.exists(output_file):
            with open(output_file, newline='') as csvfile:
                reader = csv.DictReader(csvfile)
                for row in reader:
                    row_tuple = tuple(row[field].strip() for field in ['ID', 'MAC', 'Mode', 'IPver', 'Code', 'Description', 'Label'])
                    existing_rows.add(row_tuple)
        new_rows = []
        at_least_one_detected = False
        for device_id, mac in role_dict.items():
            label = '1' if mac in llmnr_macs else '0'
            if label == '1':
                at_least_one_detected = True
            row = (str(device_id), mac, 'p,a,a+', ipver_value, 'PTV-NET-IDENT-LLMNR-PTRDEV', 'Device responds to LLMNR packets', label)
            if row not in existing_rows:
                new_rows.append(dict(zip(['ID', 'MAC', 'Mode', 'IPver', 'Code', 'Description', 'Label'], row)))
                existing_rows.add(row)
        network_label = '1' if at_least_one_detected else '0'
        network_row = ('Network', '', 'p,a,a+', ipver_value, 'PTV-NET-IDENT-LLMNR-PTR', 'Network allows the delivery of LLMNR packets', network_label)
        if network_row not in existing_rows:
            new_rows.append(dict(zip(['ID', 'MAC', 'Mode', 'IPver', 'Code', 'Description', 'Label'], network_row)))
        if new_rows:
            os.makedirs(os.path.dirname(output_file), exist_ok=True)
            write_header = not os.path.exists(output_file)
            with open(output_file, mode='a', newline='') as csvfile:
                fieldnames = ['ID', 'MAC', 'Mode', 'IPver', 'Code', 'Description', 'Label']
                writer = csv.DictWriter(csvfile, fieldnames=fieldnames)
                if write_header:
                    writer.writeheader()
                writer.writerows(new_rows)

    def store_mld_vulnerability(self, mldv1_file=f"{file_path}MLDv1.csv", mldv2_file=f"{file_path}MLDv2.csv"):
        """Output: Writes MLD vulnerabilities to CSV. Description: Checks for MLDv1/v2 responses and stores device/network results."""
        role_dict = Vulnerability.read_role_node_csv(self.role_file)
        if not isinstance(role_dict, dict) or not role_dict:
            return
        mldv1_has_data = has_additional_data(mldv1_file)
        mldv2_has_data = has_additional_data(mldv2_file)
        mldv1_macs, mldv2_macs, mldv1_global, mldv2_global = set(), set(), set(), set()
        def is_global_ipv6(ip):
            try:
                return not ipaddress.IPv6Address(ip).is_link_local
            except ValueError:
                return False
        if mldv1_has_data:
            try:
                with open(mldv1_file, newline='') as csvfile:
                    reader = csv.DictReader(csvfile)
                    for row in reader:
                        mac = row['MAC'].strip()
                        ip = row['IP'].strip()
                        mldv1_macs.add(mac)
                        if is_global_ipv6(ip):
                            mldv1_global.add(mac)
            except FileNotFoundError:
                return
        if mldv2_has_data:
            try:
                with open(mldv2_file, newline='') as csvfile:
                    reader = csv.DictReader(csvfile)
                    for row in reader:
                        mac = row['MAC'].strip()
                        ip = row['IP'].strip()
                        mldv2_macs.add(mac)
                        if is_global_ipv6(ip):
                            mldv2_global.add(mac)
            except FileNotFoundError:
                return
        existing_rows = set()
        output_file = self.vulnerability_file
        if os.path.exists(output_file):
            with open(output_file, newline='') as csvfile:
                reader = csv.reader(csvfile)
                next(reader, None)
                for row in reader:
                    if len(row) == 7:
                        row_tuple = tuple(cell.strip() for cell in row[:7])
                        existing_rows.add(row_tuple)
        new_rows = []
        detect_mldv1, detect_mldv2, detect_mldv1_global, detect_mldv2_global = False, False, False, False
        for device_id, mac in role_dict.items():
            label = '1' if mac in mldv1_macs else '0'
            if label == '1': detect_mldv1 = True
            row = (str(device_id), mac, 'a,a+', '6', 'PTV-NET-IDENT-ACTIVE-MLDV1DEV', 'Device responds to illegitimate MLDv1 queries', label)
            if row not in existing_rows:
                new_rows.append(dict(zip(['ID', 'MAC', 'Mode', 'IPver', 'Code', 'Description', 'Label'], row)))
                existing_rows.add(row)
            label = '1' if mac in mldv1_global else '0'
            if label == '1': detect_mldv1_global = True
            row = (str(device_id), mac, 'p,a,a+', '6', 'PTV-NET-NET-MISCONF-MLD1GLIPDEV', 'Device responds to MLDv1 messages from a global address', label)
            if row not in existing_rows:
                new_rows.append(dict(zip(['ID', 'MAC', 'Mode', 'IPver', 'Code', 'Description', 'Label'], row)))
                existing_rows.add(row)
            label = '1' if mac in mldv2_macs else '0'
            if label == '1': detect_mldv2 = True
            row = (str(device_id), mac, 'a,a+', '6', 'PTV-NET-IDENT-ACTIVE-MLDV2DEV', 'Device responds to illegitimate MLDv2 queries', label)
            if row not in existing_rows:
                new_rows.append(dict(zip(['ID', 'MAC', 'Mode', 'IPver', 'Code', 'Description', 'Label'], row)))
                existing_rows.add(row)
            label = '1' if mac in mldv2_global else '0'
            if label == '1': detect_mldv2_global = True
            row = (str(device_id), mac, 'p,a,a+', '6', 'PTV-NET-NET-MISCONF-MLD2GLIPDEV', 'Device responds to MLDv2 messages from a global address', label)
            if row not in existing_rows:
                new_rows.append(dict(zip(['ID', 'MAC', 'Mode', 'IPver', 'Code', 'Description', 'Label'], row)))
                existing_rows.add(row)
            label = '1' if mac in mldv1_macs and mac in mldv2_macs else '0'
            row = (str(device_id), mac, 'a,a+', '6', 'PTV-NET-IDENT-ACTIVE-MLDNVERDEV', 'Device responds to illegitimate MLDv1 queries even though MLDv2 is supported', label)
            if row not in existing_rows:
                new_rows.append(dict(zip(['ID', 'MAC', 'Mode', 'IPver', 'Code', 'Description', 'Label'], row)))
                existing_rows.add(row)
            label = '1' if mac in mldv1_macs and mac not in mldv2_macs else '0'
            row = (str(device_id), mac, 'a,a+', '6', 'PTV-NET-IDENT-ACTIVE-MLDNVERDEV2', 'Device only responds to illegitimate MLDv1 queries even though MLDv2 queries are sent, possibly downgraded', label)
            if row not in existing_rows:
                new_rows.append(dict(zip(['ID', 'MAC', 'Mode', 'IPver', 'Code', 'Description', 'Label'], row)))
                existing_rows.add(row)
        net_rows = [
            ('Network', '', 'a,a+', '6', 'PTV-NET-IDENT-ACTIVE-MLDV1', 'Network allows the delivery of illegitimate MLDv1 queries', '1' if detect_mldv1 else '0'),
            ('Network', '', 'p,a,a+', '6', 'PTV-NET-NET-MISCONF-MLD1GLIP', 'Network allows the delivery of MLDv1 messages from a global address', '1' if detect_mldv1_global else '0'),
            ('Network', '', 'a,a+', '6', 'PTV-NET-IDENT-ACTIVE-MLDV2', 'Network allows the delivery of illegitimate MLDv2 queries', '1' if detect_mldv2 else '0'),
            ('Network', '', 'p,a,a+', '6', 'PTV-NET-NET-MISCONF-MLD2GLIP', 'Network allows the delivery of MLDv2 messages from a global address', '1' if detect_mldv2_global else '0')
        ]
        for row in net_rows:
            if row not in existing_rows:
                new_rows.append(dict(zip(['ID', 'MAC', 'Mode', 'IPver', 'Code', 'Description', 'Label'], row)))
        if new_rows:
            os.makedirs(os.path.dirname(output_file), exist_ok=True)
            write_header = not os.path.exists(output_file)
            with open(output_file, mode='a', newline='') as csvfile:
                fieldnames = ['ID', 'MAC', 'Mode', 'IPver', 'Code', 'Description', 'Label']
                writer = csv.DictWriter(csvfile, fieldnames=fieldnames)
                if write_header:
                    writer.writeheader()
                writer.writerows(new_rows)

    def store_ipv6_vulnerability(self, ip_file=f"{file_path}addresses.csv"):
        """Output: Writes IPv6 predictability vulnerability to CSV. Description: Checks for predictable IPv6 global and link-local addresses."""
        role_dict = Vulnerability.read_role_node_csv(self.role_file)
        if not isinstance(role_dict, dict) or not role_dict:
            return
        ip_has_data = has_additional_data(ip_file)
        if not ip_has_data:
            return
        mac_ips = {}
        try:
            with open(ip_file, newline='') as csvfile:
                reader = csv.DictReader(csvfile)
                for row in reader:
                    mac = row['MAC'].strip()
                    ip = row['IP'].strip()
                    if mac not in mac_ips:
                        mac_ips[mac] = []
                    mac_ips[mac].append(ip)
        except FileNotFoundError:
            return
        existing_rows = set()
        output_file = self.vulnerability_file
        if os.path.exists(output_file):
            with open(output_file, newline='') as csvfile:
                reader = csv.reader(csvfile)
                next(reader, None)
                for row in reader:
                    if len(row) == 7:
                        row_tuple = tuple(cell.strip() for cell in row[:7])
                        existing_rows.add(row_tuple)
        new_rows = []
        for device_id, mac in role_dict.items():
            # Check for predictable global IPv6 address
            label_global = '0'
            if mac in mac_ips:
                for ip in mac_ips[mac]:
                    if is_global_unicast_ipv6(ip) and is_ipv6_predictable(ip, mac):
                        label_global = '1'
                        break
            row = (str(device_id), mac, 'p,a,a+', '6', 'PTV-NET-IDENT-PREDICT-GLOBIP', 'Device uses predictable IPv6 global address', label_global)
            if row not in existing_rows:
                new_rows.append(dict(zip(['ID', 'MAC', 'Mode', 'IPver', 'Code', 'Description', 'Label'], row)))
                existing_rows.add(row)
            
            # Check for predictable link-local IPv6 address
            label_linklocal = '0'
            if mac in mac_ips:
                for ip in mac_ips[mac]:
                    if is_link_local_ipv6(ip) and is_ipv6_predictable(ip, mac):
                        label_linklocal = '1'
                        break
            row = (str(device_id), mac, 'p,a,a+', '6', 'PTV-NET-IDENT-PREDICT-LINKLOCALIP', 'Device uses predictable IPv6 link-local address', label_linklocal)
            if row not in existing_rows:
                new_rows.append(dict(zip(['ID', 'MAC', 'Mode', 'IPver', 'Code', 'Description', 'Label'], row)))
                existing_rows.add(row)
        
        if new_rows:
            os.makedirs(os.path.dirname(output_file), exist_ok=True)
            write_header = not os.path.exists(output_file)
            with open(output_file, mode='a', newline='') as csvfile:
                fieldnames = ['ID', 'MAC', 'Mode', 'IPver', 'Code', 'Description', 'Label']
                writer = csv.DictWriter(csvfile, fieldnames=fieldnames)
                if write_header:
                    writer.writeheader()
                writer.writerows(new_rows)

    def store_icmp_vulnerability(self, ipver: IPMode):
        """Output: Writes ICMP vulnerabilities to CSV. Description: Checks for ICMP/ICMPv6 responses and stores device/network results."""
        role_dict = Vulnerability.read_role_node_csv(self.role_file)
        if not isinstance(role_dict, dict) or not role_dict:
            return
        icmp_file = self.time_incoming_file
        icmp_has_data = has_additional_data(icmp_file)
        if not icmp_has_data:
            return
        packet_macs = {}
        try:
            with open(icmp_file, newline='') as csvfile:
                reader = csv.DictReader(csvfile)
                for row in reader:
                    mac = row['MAC'].strip()
                    packet = row['packet'].strip()
                    if mac not in packet_macs:
                        packet_macs[mac] = []
                    packet_macs[mac].append(packet)
        except FileNotFoundError:
            return
        existing_rows = set()
        output_file = self.vulnerability_file
        if os.path.exists(output_file):
            with open(output_file, newline='') as csvfile:
                reader = csv.reader(csvfile)
                next(reader, None)
                for row in reader:
                    if len(row) == 7:
                        row_tuple = tuple(cell.strip() for cell in row[:7])
                        existing_rows.add(row_tuple)
        icmp6types = [
            "Destination unreachable", "Packet too big", "Time exceeded", "Parameter problem",
            "Echo Reply", "Redirect Message",
            "ICMP Node Information Query", "ICMP Node Information Response",
            "Inverse Neighbor Discovery Solicitation Message", "Inverse Neighbor Discovery Advertisement Message",
            "Private Experimentation"
        ]
        new_rows = []
        device_vuln = defaultdict(lambda: {
            'redirect6': False,
            'icmp6_multiecho': {'has_vuln': False, 'responses': []},
            'icmp6_invechodo': {'has_vuln': False, 'responses': []},
            'icmp6_invechohbh': {'has_vuln': False, 'responses': []},
            'icmp6_invpacket': {'has_vuln': False, 'responses': []},
            'redirect': False,
            'icmp_multiecho': False,
            'icmp_brcastecho': False,
            'icmp_invpacket': False
        })
        for device_id, mac in role_dict.items():
            if mac not in packet_macs:
                continue
            for packet in packet_macs[mac]:
                if "type = Redirect" in packet:
                    if ipver.ipv6 and "version = 6" in packet:
                        device_vuln[mac]['redirect6'] = True
                    if ipver.ipv4 and "version = 4" in packet:
                        device_vuln[mac]['redirect'] = True
                if "id = 0x6f" in packet and ipver.ipv6:
                    device_vuln[mac]['icmp6_multiecho']['has_vuln'] = True
                    for key_response in icmp6types:
                        if key_response in packet and key_response not in device_vuln[mac]['icmp6_multiecho']['responses']:
                            device_vuln[mac]['icmp6_multiecho']['responses'].append(key_response)
                if "0x14d" in packet and ipver.ipv6:
                    device_vuln[mac]['icmp6_invechodo']['has_vuln'] = True
                    for key_response in icmp6types:
                        if key_response in packet and key_response not in device_vuln[mac]['icmp6_invechodo']['responses']:
                            device_vuln[mac]['icmp6_invechodo']['responses'].append(key_response)
                if "0x1bc" in packet and ipver.ipv6:
                    device_vuln[mac]['icmp6_invechohbh']['has_vuln'] = True
                    for key_response in icmp6types:
                        if key_response in packet and key_response not in device_vuln[mac]['icmp6_invechohbh']['responses']:
                            device_vuln[mac]['icmp6_invechohbh']['responses'].append(key_response)
                if "Destination Options Header" in packet and "otype = 128" in packet and ipver.ipv6:
                    device_vuln[mac]['icmp6_invpacket']['has_vuln'] = True
                    for key_response in icmp6types:
                        if key_response in packet and key_response not in device_vuln[mac]['icmp6_invpacket']['responses']:
                            device_vuln[mac]['icmp6_invpacket']['responses'].append(key_response)
                if "0x29a" in packet and ipver.ipv4:
                    device_vuln[mac]['icmp_multiecho'] = True
                if "0x309" in packet and ipver.ipv4:
                    device_vuln[mac]['icmp_brcastecho'] = True
                if "type = 255" in packet and ipver.ipv4:
                    device_vuln[mac]['icmp_invpacket'] = True
        for device_id, mac in role_dict.items():
            if ipver.ipv6:
                label = '1' if device_vuln[mac]['redirect6'] else '0'
                row = (str(device_id), mac, 'p,a,a+', '6', 'PTV-NET-MITM-ICMP6REDIRDEV', 'Device communication can be redirected using ICMPv6 Redirect', label)
                if row not in existing_rows:
                    new_rows.append(dict(zip(['ID', 'MAC', 'Mode', 'IPver', 'Code', 'Description', 'Label'], row)))
                    existing_rows.add(row)
                if device_vuln[mac]['icmp6_multiecho']['has_vuln'] and device_vuln[mac]['icmp6_multiecho']['responses']:
                    response_string = ' / '.join(device_vuln[mac]['icmp6_multiecho']['responses'])
                    description = f'Device responds to standard multicast ICMPv6 Echo Request with {response_string} message'
                    label = '1'
                else:
                    description = 'Device responds to standard multicast ICMPv6 Echo Request'
                    label = '0'
                row = (str(device_id), mac, 'p,a,a+', '6', 'PTV-NET-IDENT-ICMP6-MULTIECHODEV', description, label)
                if row not in existing_rows:
                    new_rows.append(dict(zip(['ID', 'MAC', 'Mode', 'IPver', 'Code', 'Description', 'Label'], row)))
                    existing_rows.add(row)
                if device_vuln[mac]['icmp6_invechodo']['has_vuln'] and device_vuln[mac]['icmp6_invechodo']['responses']:
                    response_string = ' / '.join(device_vuln[mac]['icmp6_invechodo']['responses'])
                    description = f'Device responds to invalid Destination Option ICMPv6 Echo Request with {response_string} message'
                    label = '1'
                else:
                    description = 'Device responds to invalid Destination Option ICMPv6 Echo Request'
                    label = '0'
                row = (str(device_id), mac, 'p,a,a+', '6', 'PTV-NET-IDENT-ICMP6-INVECHODODEV', description, label)
                if row not in existing_rows:
                    new_rows.append(dict(zip(['ID', 'MAC', 'Mode', 'IPver', 'Code', 'Description', 'Label'], row)))
                    existing_rows.add(row)
                if device_vuln[mac]['icmp6_invechohbh']['has_vuln'] and device_vuln[mac]['icmp6_invechohbh']['responses']:
                    response_string = ' / '.join(device_vuln[mac]['icmp6_invechohbh']['responses'])
                    description = f'Device responds to invalid Hop-by-Hop ICMPv6 Echo Request with {response_string} message'
                    label = '1'
                else:
                    description = 'Device responds to invalid Hop-by-Hop ICMPv6 Echo Request'
                    label = '0'
                row = (str(device_id), mac, 'p,a,a+', '6', 'PTV-NET-IDENT-ICMP6-INVECHOHBHDEV', description, label)
                if row not in existing_rows:
                    new_rows.append(dict(zip(['ID', 'MAC', 'Mode', 'IPver', 'Code', 'Description', 'Label'], row)))
                    existing_rows.add(row)
                if device_vuln[mac]['icmp6_invpacket']['has_vuln'] and device_vuln[mac]['icmp6_invpacket']['responses']:
                    response_string = ' / '.join(device_vuln[mac]['icmp6_invpacket']['responses'])
                    description = f'Device responds to invalid ICMPv6 packets with {response_string} message'
                    label = '1'
                else:
                    description = 'Device responds to invalid ICMPv6 packets'
                    label = '0'
                row = (str(device_id), mac, 'p,a,a+', '6', 'PTV-NET-IDENT-ICMP6-INVPACKETDEV', description, label)
                if row not in existing_rows:
                    new_rows.append(dict(zip(['ID', 'MAC', 'Mode', 'IPver', 'Code', 'Description', 'Label'], row)))
                    existing_rows.add(row)
            if ipver.ipv4:
                label = '1' if device_vuln[mac]['redirect'] else '0'
                row = (str(device_id), mac, 'p,a,a+', '4', 'PTV-NET-MITM-ICMPREDIRDEV', 'Device communication can be redirected using ICMP Redirect', label)
                if row not in existing_rows:
                    new_rows.append(dict(zip(['ID', 'MAC', 'Mode', 'IPver', 'Code', 'Description', 'Label'], row)))
                    existing_rows.add(row)
                label = '1' if device_vuln[mac]['icmp_multiecho'] else '0'
                row = (str(device_id), mac, 'p,a,a+', '4', 'PTV-NET-IDENT-ICMP-MULTIECHODEV', 'Device responds to standard multicast ICMP Echo Request', label)
                if row not in existing_rows:
                    new_rows.append(dict(zip(['ID', 'MAC', 'Mode', 'IPver', 'Code', 'Description', 'Label'], row)))
                    existing_rows.add(row)
                label = '1' if device_vuln[mac]['icmp_brcastecho'] else '0'
                row = (str(device_id), mac, 'p,a,a+', '4', 'PTV-NET-IDENT-ICMP-BRCASTECHODEV', 'Device responds to standard broadcast ICMP Echo Request', label)
                if row not in existing_rows:
                    new_rows.append(dict(zip(['ID', 'MAC', 'Mode', 'IPver', 'Code', 'Description', 'Label'], row)))
                    existing_rows.add(row)
                label = '1' if device_vuln[mac]['icmp_invpacket'] else '0'
                row = (str(device_id), mac, 'p,a,a+', '4', 'PTV-NET-IDENT-ICMP-INVPACKETDEV', 'Device responds to invalid ICMP packets', label)
                if row not in existing_rows:
                    new_rows.append(dict(zip(['ID', 'MAC', 'Mode', 'IPver', 'Code', 'Description', 'Label'], row)))
                    existing_rows.add(row)
        def net_label(key):
            if isinstance(device_vuln[list(role_dict.values())[0]][key], dict):
                return '1' if any(device_vuln[mac][key]['has_vuln'] for mac in role_dict.values()) else '0'
            else:
                return '1' if any(device_vuln[mac][key] for mac in role_dict.values()) else '0'
        net_rows = [
            ('PTV-NET-MITM-ICMPREDIR', 'Network does not block ICMP Redirect messages', net_label('redirect'), '4'),
            ('PTV-NET-MITM-ICMP6REDIR', 'Network does not block ICMPv6 Redirect messages', net_label('redirect6'), '6'),
            ('PTV-NET-IDENT-ICMP6-MULTIECHO', 'Network allows the delivery of standard multicast ICMPv6 Echo Request', net_label('icmp6_multiecho'), '6'),
            ('PTV-NET-IDENT-ICMP6-INVECHODO', 'Network allows the delivery of invalid Destination Option ICMPv6 Echo Request', net_label('icmp6_invechodo'), '6'),
            ('PTV-NET-IDENT-ICMP6-INVECHOHBH', 'Network allows the delivery of invalid Hop-by-Hop ICMPv6 Echo Request', net_label('icmp6_invechohbh'), '6'),
            ('PTV-NET-IDENT-ICMP6-INVPACKET', 'Network allows the delivery of invalid ICMPv6 packets', net_label('icmp6_invpacket'), '6'),
            ('PTV-NET-IDENT-ICMP-MULTIECHO', 'Network allows the delivery of standard multicast ICMP Echo Request', net_label('icmp_multiecho'), '4'),
            ('PTV-NET-IDENT-ICMP-BRCASTECHO', 'Network allows the delivery of standard broadcast ICMP Echo Request', net_label('icmp_brcastecho'), '4'),
            ('PTV-NET-IDENT-ICMP-INVPACKET', 'Network allows the delivery of invalid ICMP packets', net_label('icmp_invpacket'), '4'),
        ]
        for code, desc, label, version in net_rows:
            row = ('Network', '', 'p,a,a+', version, code, desc, label)
            if row not in existing_rows:
                if (ipver.ipv4 and version == '4') or (ipver.ipv6 and version == '6'):
                    new_rows.append(dict(zip(['ID', 'MAC', 'Mode', 'IPver', 'Code', 'Description', 'Label'], row)))
                    existing_rows.add(row)
        if new_rows:
            unique_rows = {}
            for row in new_rows:
                key = (row['MAC'], row['Code'], row['IPver'])
                if key not in unique_rows:
                    unique_rows[key] = row
                else:
                    current_desc_len = len(row['Description'])
                    existing_desc_len = len(unique_rows[key]['Description'])
                    if current_desc_len > existing_desc_len:
                        unique_rows[key] = row
            filtered_rows = list(unique_rows.values())
            os.makedirs(os.path.dirname(output_file), exist_ok=True)
            write_header = not os.path.exists(output_file)
            with open(output_file, mode='a', newline='') as csvfile:
                fieldnames = ['ID', 'MAC', 'Mode', 'IPver', 'Code', 'Description', 'Label']
                writer = csv.DictWriter(csvfile, fieldnames=fieldnames)
                if write_header:
                    writer.writeheader()
                writer.writerows(filtered_rows)
                
    def store_ra_vulnerability(self, ra_file=f"{file_path}RA.csv"):
        """Output: Writes RA vulnerabilities to CSV. Description: Checks for fraudulent RA/DNS and stores device/network results."""
        def extract_ipv6_dst(text):
            matches = re.findall(r'dst\s*=\s*([a-fA-F0-9:]+)', text)
            for match in matches:
                if ':' in match and not re.match(r'^([0-9A-Fa-f]{2}:){5}[0-9A-Fa-f]{2}$', match):
                    return match
            return None
        def extract_ipv6_src(text):
            matches = re.findall(r'src\s*=\s*([a-fA-F0-9:]+)', text)
            for match in matches:
                if ':' in match and not re.match(r'^([0-9A-Fa-f]{2}:){5}[0-9A-Fa-f]{2}$', match):
                    return match
            return None
        try:
            role_dict = Vulnerability.read_role_node_csv(self.role_file)
            if not isinstance(role_dict, dict) or not role_dict:
                return
        except Exception:
            return
        if not has_additional_data(ra_file):
            return
        mac_preferences = {}
        try:
            with open(ra_file, 'r', newline='') as csvfile:
                reader = csv.DictReader(csvfile)
                required_columns = ['MAC', 'DNS', 'M', 'O', 'Preference']
                if not all(col in reader.fieldnames for col in required_columns):
                    return
                for row in reader:
                    mac = row['MAC'].strip()
                    mac_preferences[mac] = row['Preference'].strip()
        except FileNotFoundError:
            return
        except Exception:
            return
        mac_packets = {}
        try:
            with open(self.time_incoming_file, 'r', newline='') as csvfile:
                reader = csv.DictReader(csvfile)
                required_columns = ['MAC', 'packet']
                if not all(col in reader.fieldnames for col in required_columns):
                    return
                for row in reader:
                    mac = row['MAC'].strip()
                    packet = row['packet'].strip()
                    if mac not in mac_packets:
                        mac_packets[mac] = []
                    mac_packets[mac].append(packet)
        except FileNotFoundError:
            return
        except Exception:
            return
        existing_rows = set()
        output_file = self.vulnerability_file
        if os.path.exists(output_file):
            try:
                with open(output_file, 'r', newline='') as csvfile:
                    reader = csv.reader(csvfile)
                    next(reader, None)
                    for row in reader:
                        if len(row) == 7:
                            row_tuple = tuple(cell.strip() for cell in row[:7])
                            existing_rows.add(row_tuple)
            except Exception:
                return
        new_rows = []
        detect_fakeradns = False
        detect_raguard = False
        detect_fakera = False
        detect_icmp6_outrange = False
        
        # Track devices with FAKERADNS and ICMP6-OUTRANGE vulnerabilities
        device_fakeradns = defaultdict(lambda: False)
        device_fakera = defaultdict(lambda: False)
        device_icmp6_outrange = defaultdict(lambda: False)
        
        # Check FAKERADNS only if DNS is configured
        if self.dns is not None:
            for device_number, mac in role_dict.items():
                for dns_ip in self.dns:
                    if is_valid_ipv6(dns_ip):
                        for packet in mac_packets.get(mac, []):
                            if f"dst = {dns_ip}" in packet:
                                detect_fakeradns = True
                                detect_fakera = True
                                detect_raguard = True
                                device_fakeradns[mac] = True
                                device_fakera[mac] = True
                                break
        
        # Check for packets from outside the network range
        with open(self.time_incoming_file, 'r', newline='') as time_file:
            time_reader = csv.reader(time_file)
            time_header = next(time_reader)
            src_mac_index = time_header.index('MAC')
            packet_index = time_header.index('packet')
            for row in time_reader:
                if f"dst = {self.smac}" in row[packet_index]:
                    dst_ip = extract_ipv6_dst(row[packet_index])
                    if dst_ip is not None and is_global_unicast_ipv6(dst_ip) and dst_ip not in Interface(self.interface).get_interface_ipv6_ips():
                        detect_fakera = True
                        detect_raguard = True
                        detect_icmp6_outrange = True
                        device_fakera[row[src_mac_index]] = True
                        device_icmp6_outrange[row[src_mac_index]] = True
                if self.network:
                    if check_ipv6_addresses_generated_from_prefix(extract_ipv6_src(row[packet_index]), f"{self.network}/{self.prefix_len}"):
                        detect_fakera = True
                        detect_raguard = True
                        device_fakera[row[src_mac_index]] = True
        
        # Add device vulnerabilities
        for device_number, mac in role_dict.items():
            # FAKERADNS vulnerabilities
            if self.dns is not None:
                # Only add if DNS is configured - true/false detection
                row1 = (
                    str(device_number),
                    mac, 'a+', '6',
                    'PTV-NET-MITM-FAKERADNSDEV',
                    'Device connects to a fraudulent DNS server through a spoofed RA message',
                    '1' if device_fakeradns[mac] else '0'
                )
                if row1 not in existing_rows:
                    new_rows.append(dict(zip(['ID', 'MAC', 'Mode', 'IPver', 'Code', 'Description', 'Label'], row1)))
                    existing_rows.add(row1)
            else:
                # DNS not configured - N/A
                row1 = (
                    str(device_number),
                    mac, 'a+', '6',
                    'PTV-NET-MITM-FAKERADNSDEV',
                    'Device connects to a fraudulent DNS server through a spoofed RA message',
                    '2'  # 2 indicates N/A
                )
                if row1 not in existing_rows:
                    new_rows.append(dict(zip(['ID', 'MAC', 'Mode', 'IPver', 'Code', 'Description', 'Label'], row1)))
                    existing_rows.add(row1)
            
            # FAKERA vulnerability
            row2 = (
                str(device_number),
                mac, 'a+', '6',
                'PTV-NET-NET-MISCONF-FAKERADEV',
                'Device does not ignore the illegitimate RA packets',
                '1' if device_fakera[mac] else '0'
            )
            if row2 not in existing_rows:
                new_rows.append(dict(zip(['ID', 'MAC', 'Mode', 'IPver', 'Code', 'Description', 'Label'], row2)))
                existing_rows.add(row2)
            
            # ICMP6-OUTRANGE vulnerability
            row3 = (
                str(device_number),
                mac, 'a+', '6',
                'PTV-NET-IDENT-ICMP6-OUTRANGEDEV',
                'Device responds to valid or invalid ICMPv6 packets from sources outside the scanned local network range',
                '1' if device_icmp6_outrange[mac] else '0'
            )
            if row3 not in existing_rows:
                new_rows.append(dict(zip(['ID', 'MAC', 'Mode', 'IPver', 'Code', 'Description', 'Label'], row3)))
                existing_rows.add(row3)
        
        # Add network vulnerabilities
        net_rows = [
            (
                'Network',
                '', 'a+', '6',
                'PTV-NET-MITM-FAKERADNS',
                'Network allows a client to be forced to use a fraudulent DNS server through a spoofed RA message',
                '1' if detect_fakeradns else '0' if self.dns is not None else '2' # 2 indicates N/A
            ),
            (
                'Network',
                '', 'a+', '6',
                'PTV-NET-MISCONF-RAGUARD',
                'Network does not have RA guard configured',
                '1' if detect_raguard else '0'
            ),
            (
                'Network',
                '', 'a+', '6',
                'PTV-NET-NET-MISCONF-FAKERA',
                'Network allows the delivery of illegitimate RA packets',
                '1' if detect_fakera else '0'
            ),
            (
                'Network',
                '', 'a+', '6',
                'PTV-NET-IDENT-ICMP6-OUTRANGE',
                'Network allows valid or invalid ICMPv6 packets to be delivered from sources outside the scanned local network range',
                '1' if detect_icmp6_outrange else '0'
            )
        ]
        for row in net_rows:
            if row not in existing_rows:
                new_rows.append(dict(zip(['ID', 'MAC', 'Mode', 'IPver', 'Code', 'Description', 'Label'], row)))
        
        if new_rows:
            try:
                os.makedirs(os.path.dirname(output_file), exist_ok=True)
                write_header = not os.path.exists(output_file)
                with open(output_file, 'a', newline='') as csvfile:
                    fieldnames = ['ID', 'MAC', 'Mode', 'IPver', 'Code', 'Description', 'Label']
                    writer = csv.DictWriter(csvfile, fieldnames=fieldnames)
                    if write_header:
                        writer.writeheader()
                    writer.writerows(new_rows)
            except Exception:
                return
    
    def store_dnssd_vulnerability(self, ipver: IPMode):
        """Output: Writes DNS-SD vulnerability to CSV. Description: Checks for DNS Service Discovery responses and stores device/network results."""
        role_dict = Vulnerability.read_role_node_csv(self.role_file)
        if not isinstance(role_dict, dict) or not role_dict:
            return
        incoming_file = self.time_incoming_file
        if not has_additional_data(incoming_file):
            return

        if ipver.ipv4 and ipver.ipv6:
            ipver_value = 'both'
        elif ipver.ipv4:
            ipver_value = '4'
        elif ipver.ipv6:
            ipver_value = '6'
        else:
            return

        # Collect packets per MAC
        mac_dnssd = set()
        try:
            with open(incoming_file, newline='') as csvfile:
                reader = csv.DictReader(csvfile)
                if not {'MAC', 'packet'}.issubset(set(reader.fieldnames or [])):
                    return
                for row in reader:
                    mac = row['MAC'].strip()
                    packet = row['packet'].strip()
                    if 'dns' in packet and 'dns-sd._udp.local' in packet:
                        mac_dnssd.add(mac)
        except FileNotFoundError:
            return
        except Exception:
            return

        output_file = self.vulnerability_file
        existing_rows = set()
        if os.path.exists(output_file):
            try:
                with open(output_file, newline='') as csvfile:
                    reader = csv.DictReader(csvfile)
                    for row in reader:
                        row_tuple = tuple(row[field].strip() for field in ['ID', 'MAC', 'Mode', 'IPver', 'Code', 'Description', 'Label'])
                        existing_rows.add(row_tuple)
            except Exception:
                return

        new_rows = []
        at_least_one_detected = False
        for device_id, mac in role_dict.items():
            label = '1' if mac in mac_dnssd else '0'
            if label == '1':
                at_least_one_detected = True
            row = (str(device_id), mac, 'p,a,a+', ipver_value,
                   'PTV-NET-IDENT-DNS-SDDEV', 'Device responds to DNS Service Discovery packets', label)
            if row not in existing_rows:
                new_rows.append(dict(zip(
                    ['ID', 'MAC', 'Mode', 'IPver', 'Code', 'Description', 'Label'], row)))
                existing_rows.add(row)

        network_label = '1' if at_least_one_detected else '0'
        network_row = ('Network', '', 'p,a,a+', ipver_value,
                       'PTV-NET-IDENT-DNS-SD', 'Network allows devices discovery with DNS Service Discovery', network_label)
        if network_row not in existing_rows:
            new_rows.append(dict(zip(
                ['ID', 'MAC', 'Mode', 'IPver', 'Code', 'Description', 'Label'], network_row)))
            existing_rows.add(network_row)

        if new_rows:
            try:
                os.makedirs(os.path.dirname(output_file), exist_ok=True)
                write_header = not os.path.exists(output_file)
                with open(output_file, mode='a', newline='') as csvfile:
                    fieldnames = ['ID', 'MAC', 'Mode', 'IPver', 'Code', 'Description', 'Label']
                    writer = csv.DictWriter(csvfile, fieldnames=fieldnames)
                    if write_header:
                        writer.writeheader()
                    writer.writerows(new_rows)
            except Exception:
                return
    
    def store_ws_vulnerability(self, ipver: IPMode):
        """Output: Writes WS-Disocvery vulnerability to CSV. Description: Checks for WS-Disocvery responses and stores device/network results."""
        role_dict = Vulnerability.read_role_node_csv(self.role_file)
        if not isinstance(role_dict, dict) or not role_dict:
            return
        incoming_file = self.time_incoming_file
        if not has_additional_data(incoming_file):
            return

        if ipver.ipv4 and ipver.ipv6:
            ipver_value = 'both'
        elif ipver.ipv4:
            ipver_value = '4'
        elif ipver.ipv6:
            ipver_value = '6'
        else:
            return

        # Collect packets per MAC
        mac_dnsws = set()
        try:
            with open(incoming_file, newline='') as csvfile:
                reader = csv.DictReader(csvfile)
                if not {'MAC', 'packet'}.issubset(set(reader.fieldnames or [])):
                    return
                for row in reader:
                    mac = row['MAC'].strip()
                    packet = row['packet'].strip()
                    if 'UDP' in packet and 'sport = 3702' in packet:
                        mac_dnsws.add(mac)
        except FileNotFoundError:
            return
        except Exception:
            return

        output_file = self.vulnerability_file
        existing_rows = set()
        if os.path.exists(output_file):
            try:
                with open(output_file, newline='') as csvfile:
                    reader = csv.DictReader(csvfile)
                    for row in reader:
                        row_tuple = tuple(row[field].strip() for field in ['ID', 'MAC', 'Mode', 'IPver', 'Code', 'Description', 'Label'])
                        existing_rows.add(row_tuple)
            except Exception:
                return

        new_rows = []
        at_least_one_detected = False
        for device_id, mac in role_dict.items():
            label = '1' if mac in mac_dnsws else '0'
            if label == '1':
                at_least_one_detected = True
            row = (str(device_id), mac, 'p,a,a+', ipver_value,
                   'PTV-NET-IDENT-WSDEV', 'Device responds to WS-Discovery packets', label)
            if row not in existing_rows:
                new_rows.append(dict(zip(
                    ['ID', 'MAC', 'Mode', 'IPver', 'Code', 'Description', 'Label'], row)))
                existing_rows.add(row)

        network_label = '1' if at_least_one_detected else '0'
        network_row = ('Network', '', 'p,a,a+', ipver_value,
                       'PTV-NET-IDENT-WS', 'Network allows devices discovery with WS-Discovery', network_label)
        if network_row not in existing_rows:
            new_rows.append(dict(zip(
                ['ID', 'MAC', 'Mode', 'IPver', 'Code', 'Description', 'Label'], network_row)))
            existing_rows.add(network_row)

        if new_rows:
            try:
                os.makedirs(os.path.dirname(output_file), exist_ok=True)
                write_header = not os.path.exists(output_file)
                with open(output_file, mode='a', newline='') as csvfile:
                    fieldnames = ['ID', 'MAC', 'Mode', 'IPver', 'Code', 'Description', 'Label']
                    writer = csv.DictWriter(csvfile, fieldnames=fieldnames)
                    if write_header:
                        writer.writeheader()
                    writer.writerows(new_rows)
            except Exception:
                return
    
    