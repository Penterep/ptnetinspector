import csv
from collections import defaultdict
import re
from libs.check import has_additional_data, is_global_unicast_ipv6, is_valid_ipv4, is_valid_ipv6, check_ipv6_addresses_generated_from_prefix, is_ipv6_predictable
from libs.convert import convert_preferenceRA
from src.create_csv import sort_and_deduplicate_csv
from src.interface import Interface
from src.send import IPMode
import os
import ipaddress

file_path = "src/tmp/"

class Vulnerability:
    def __init__(self, interface:str, prefix_len:int, network:str, smac:str, rpref:int, dns:list[str], role_file=f"{file_path}role_node.csv", time_incoming_file=f"{file_path}time_incoming.csv", vulnerability_file=f"{file_path}vulnerability.csv"):
        self.role_file = role_file
        self.time_incoming_file = time_incoming_file
        self.vulnerability_file = vulnerability_file
        self.interface = interface
        self.prefix_len = prefix_len
        self.network = network
        self.smac = smac
        self.pref = convert_preferenceRA(rpref)
        self.dns = dns

    @staticmethod
    def read_role_node_csv(filename=f"{file_path}role_node.csv"):
        """Return the dictionary of sorted devices with their corresponding MAC"""
        result = {}
        if not has_additional_data(filename):
            return
        with open(filename, newline='') as csvfile:
            reader = csv.DictReader(csvfile)
            for row in reader:
                try:
                    device_number = int(row['Device_Number'].strip())
                    mac = row['MAC'].strip()
                    result[device_number] = mac
                except (ValueError, KeyError):
                    continue
        return dict(sorted(result.items()))

    def handle_vulnerabilities(self, mode:str, ipver:IPMode):
        """Main entry to handle all vulnerabilities. Output: None. Description: Orchestrates vulnerability checks and writes results to CSV."""
        if mode == "802.1x":
            self.store_eap_vulnerability()
        if mode in ['p', 'a', 'a+']:
            self.store_MDNS_vulnerability(ipver=ipver)
            self.store_llmnr_vulnerability(ipver=ipver)
            self.store_icmp_vulnerability(ipver)
            if ipver.ipv6:
                self.store_mld_vulnerability()
                self.store_ipv6_vulnerability()
            if ipver.ipv4:
                pass
        if mode == "a+":
            if ipver.ipv6:
                self.store_ra_vulnerability()
        sort_and_deduplicate_csv(self.vulnerability_file)

    def store_eap_vulnerability(self, eap_file=f"{file_path}eap.csv"):
        """Output: Writes EAP vulnerability to CSV. Description: Checks for 802.1x deployment and stores result."""
        detect_eap = has_additional_data(eap_file)
        existing_rows = set()
        output_file = self.vulnerability_file
        if os.path.exists(output_file):
            with open(output_file, 'r') as file:
                reader = csv.reader(file)
                next(reader, None)
                for row in reader:
                    if len(row) == 7:
                        row_tuple = tuple(cell.strip() for cell in row[:7])
                        existing_rows.add(row_tuple)
        new_rows = []
        network_row = ('Network', '', '802.1x', '', 'PTV-NET-NET-MISCONF-8021X', 'Network does not have 802.1x deployed', '0' if detect_eap else '1')
        if network_row not in existing_rows:
            new_rows.append({
                'ID': network_row[0],
                'MAC': network_row[1],
                'Mode': network_row[2],
                'IPver': network_row[3],
                'Code': network_row[4],
                'Description': network_row[5],
                'Label': network_row[6]
            })
        if new_rows:
            os.makedirs(os.path.dirname(output_file), exist_ok=True)
            write_header = not os.path.exists(output_file)
            with open(output_file, mode='a', newline='') as csvfile:
                fieldnames = ['ID', 'MAC', 'Mode', 'IPver', 'Code', 'Description', 'Label']
                writer = csv.DictWriter(csvfile, fieldnames=fieldnames)
                if write_header:
                    writer.writeheader()
                writer.writerows(new_rows)

    def store_MDNS_vulnerability(self, MDNS_file=f"{file_path}MDNS.csv", ipver=IPMode(True, True)):
        """Output: Writes MDNS vulnerability to CSV. Description: Checks for MDNS responses and stores device/network results."""
        role_dict = Vulnerability.read_role_node_csv(self.role_file)
        if not isinstance(role_dict, dict) or not role_dict:
            return
        MDNS_has_data = has_additional_data(MDNS_file)
        if ipver.ipv4 and ipver.ipv6:
            ipver_value = 'both'
        elif ipver.ipv4:
            ipver_value = '4'
        elif ipver.ipv6:
            ipver_value = '6'
        else:
            return
        mdns_macs = set()
        if MDNS_has_data:
            try:
                with open(MDNS_file, newline='') as csvfile:
                    reader = csv.DictReader(csvfile)
                    for row in reader:
                        mac = row['MAC'].strip()
                        mdns_macs.add(mac)
            except FileNotFoundError:
                return
        existing_rows = set()
        output_file = self.vulnerability_file
        if os.path.exists(output_file):
            with open(output_file, newline='') as csvfile:
                reader = csv.DictReader(csvfile)
                for row in reader:
                    row_tuple = tuple(row[field].strip() for field in ['ID', 'MAC', 'Mode', 'IPver', 'Code', 'Description', 'Label'])
                    existing_rows.add(row_tuple)
        new_rows = []
        at_least_one_detected = False
        for device_id, mac in role_dict.items():
            label = '1' if mac in mdns_macs else '0'
            if label == '1':
                at_least_one_detected = True
            row = (str(device_id), mac, 'p,a,a+', ipver_value, 'PTV-NET-IDENT-MDNS-PTRDEV', 'Device responds to MDNS packets', label)
            if row not in existing_rows:
                new_rows.append(dict(zip(['ID', 'MAC', 'Mode', 'IPver', 'Code', 'Description', 'Label'], row)))
                existing_rows.add(row)
        network_label = '1' if at_least_one_detected else '0'
        network_row = ('Network', '', 'p,a,a+', ipver_value, 'PTV-NET-IDENT-MDNS-PTR', 'Network allows the delivery of MDNS packets', network_label)
        if network_row not in existing_rows:
            new_rows.append(dict(zip(['ID', 'MAC', 'Mode', 'IPver', 'Code', 'Description', 'Label'], network_row)))
        if new_rows:
            os.makedirs(os.path.dirname(output_file), exist_ok=True)
            write_header = not os.path.exists(output_file)
            with open(output_file, mode='a', newline='') as csvfile:
                fieldnames = ['ID', 'MAC', 'Mode', 'IPver', 'Code', 'Description', 'Label']
                writer = csv.DictWriter(csvfile, fieldnames=fieldnames)
                if write_header:
                    writer.writeheader()
                writer.writerows(new_rows)

    def store_llmnr_vulnerability(self, llmnr_file=f"{file_path}LLMNR.csv", ipver=IPMode(True, True)):
        """Output: Writes LLMNR vulnerability to CSV. Description: Checks for LLMNR responses and stores device/network results."""
        role_dict = Vulnerability.read_role_node_csv(self.role_file)
        if not isinstance(role_dict, dict) or not role_dict:
            return
        llmnr_has_data = has_additional_data(llmnr_file)
        if ipver.ipv4 and ipver.ipv6:
            ipver_value = 'both'
        elif ipver.ipv4:
            ipver_value = '4'
        elif ipver.ipv6:
            ipver_value = '6'
        else:
            return
        llmnr_macs = set()
        if llmnr_has_data:
            try:
                with open(llmnr_file, newline='') as csvfile:
                    reader = csv.DictReader(csvfile)
                    for row in reader:
                        mac = row['MAC'].strip()
                        llmnr_macs.add(mac)
            except FileNotFoundError:
                return
        existing_rows = set()
        output_file = self.vulnerability_file
        if os.path.exists(output_file):
            with open(output_file, newline='') as csvfile:
                reader = csv.DictReader(csvfile)
                for row in reader:
                    row_tuple = tuple(row[field].strip() for field in ['ID', 'MAC', 'Mode', 'IPver', 'Code', 'Description', 'Label'])
                    existing_rows.add(row_tuple)
        new_rows = []
        at_least_one_detected = False
        for device_id, mac in role_dict.items():
            label = '1' if mac in llmnr_macs else '0'
            if label == '1':
                at_least_one_detected = True
            row = (str(device_id), mac, 'p,a,a+', ipver_value, 'PTV-NET-IDENT-LLMNR-PTRDEV', 'Device responds to LLMNR packets', label)
            if row not in existing_rows:
                new_rows.append(dict(zip(['ID', 'MAC', 'Mode', 'IPver', 'Code', 'Description', 'Label'], row)))
                existing_rows.add(row)
        network_label = '1' if at_least_one_detected else '0'
        network_row = ('Network', '', 'p,a,a+', ipver_value, 'PTV-NET-IDENT-LLMNR-PTR', 'Network allows the delivery of LLMNR packets', network_label)
        if network_row not in existing_rows:
            new_rows.append(dict(zip(['ID', 'MAC', 'Mode', 'IPver', 'Code', 'Description', 'Label'], network_row)))
        if new_rows:
            os.makedirs(os.path.dirname(output_file), exist_ok=True)
            write_header = not os.path.exists(output_file)
            with open(output_file, mode='a', newline='') as csvfile:
                fieldnames = ['ID', 'MAC', 'Mode', 'IPver', 'Code', 'Description', 'Label']
                writer = csv.DictWriter(csvfile, fieldnames=fieldnames)
                if write_header:
                    writer.writeheader()
                writer.writerows(new_rows)

    def store_mld_vulnerability(self, mldv1_file=f"{file_path}MLDv1.csv", mldv2_file=f"{file_path}MLDv2.csv"):
        """Output: Writes MLD vulnerabilities to CSV. Description: Checks for MLDv1/v2 responses and stores device/network results."""
        role_dict = Vulnerability.read_role_node_csv(self.role_file)
        if not isinstance(role_dict, dict) or not role_dict:
            return
        mldv1_has_data = has_additional_data(mldv1_file)
        mldv2_has_data = has_additional_data(mldv2_file)
        mldv1_macs, mldv2_macs, mldv1_global, mldv2_global = set(), set(), set(), set()
        def is_global_ipv6(ip):
            try:
                return not ipaddress.IPv6Address(ip).is_link_local
            except ValueError:
                return False
        if mldv1_has_data:
            try:
                with open(mldv1_file, newline='') as csvfile:
                    reader = csv.DictReader(csvfile)
                    for row in reader:
                        mac = row['MAC'].strip()
                        ip = row['IP'].strip()
                        mldv1_macs.add(mac)
                        if is_global_ipv6(ip):
                            mldv1_global.add(mac)
            except FileNotFoundError:
                return
        if mldv2_has_data:
            try:
                with open(mldv2_file, newline='') as csvfile:
                    reader = csv.DictReader(csvfile)
                    for row in reader:
                        mac = row['MAC'].strip()
                        ip = row['IP'].strip()
                        mldv2_macs.add(mac)
                        if is_global_ipv6(ip):
                            mldv2_global.add(mac)
            except FileNotFoundError:
                return
        existing_rows = set()
        output_file = self.vulnerability_file
        if os.path.exists(output_file):
            with open(output_file, newline='') as csvfile:
                reader = csv.reader(csvfile)
                next(reader, None)
                for row in reader:
                    if len(row) == 7:
                        row_tuple = tuple(cell.strip() for cell in row[:7])
                        existing_rows.add(row_tuple)
        new_rows = []
        detect_mldv1, detect_mldv2, detect_mldv1_global, detect_mldv2_global = False, False, False, False
        for device_id, mac in role_dict.items():
            label = '1' if mac in mldv1_macs else '0'
            if label == '1': detect_mldv1 = True
            row = (str(device_id), mac, 'a,a+', '6', 'PTV-NET-IDENT-ACTIVE-MLDV1DEV', 'Device responds to illegitimate MLDv1 queries', label)
            if row not in existing_rows:
                new_rows.append(dict(zip(['ID', 'MAC', 'Mode', 'IPver', 'Code', 'Description', 'Label'], row)))
                existing_rows.add(row)
            label = '1' if mac in mldv1_global else '0'
            if label == '1': detect_mldv1_global = True
            row = (str(device_id), mac, 'p,a,a+', '6', 'PTV-NET-NET-MISCONF-MLD1GLIPDEV', 'Device responds to MLDv1 messages from a global address', label)
            if row not in existing_rows:
                new_rows.append(dict(zip(['ID', 'MAC', 'Mode', 'IPver', 'Code', 'Description', 'Label'], row)))
                existing_rows.add(row)
            label = '1' if mac in mldv2_macs else '0'
            if label == '1': detect_mldv2 = True
            row = (str(device_id), mac, 'a,a+', '6', 'PTV-NET-IDENT-ACTIVE-MLDV2DEV', 'Device responds to illegitimate MLDv2 queries', label)
            if row not in existing_rows:
                new_rows.append(dict(zip(['ID', 'MAC', 'Mode', 'IPver', 'Code', 'Description', 'Label'], row)))
                existing_rows.add(row)
            label = '1' if mac in mldv2_global else '0'
            if label == '1': detect_mldv2_global = True
            row = (str(device_id), mac, 'p,a,a+', '6', 'PTV-NET-NET-MISCONF-MLD2GLIPDEV', 'Device responds to MLDv2 messages from a global address', label)
            if row not in existing_rows:
                new_rows.append(dict(zip(['ID', 'MAC', 'Mode', 'IPver', 'Code', 'Description', 'Label'], row)))
                existing_rows.add(row)
            label = '1' if mac in mldv1_macs and mac in mldv2_macs else '0'
            row = (str(device_id), mac, 'a,a+', '6', 'PTV-NET-IDENT-ACTIVE-MLDNVERDEV', 'Device responds to illegitimate MLDv1 queries even though MLDv2 is supported', label)
            if row not in existing_rows:
                new_rows.append(dict(zip(['ID', 'MAC', 'Mode', 'IPver', 'Code', 'Description', 'Label'], row)))
                existing_rows.add(row)
            label = '1' if mac in mldv1_macs and mac not in mldv2_macs else '0'
            row = (str(device_id), mac, 'a,a+', '6', 'PTV-NET-IDENT-ACTIVE-MLDNVERDEV2', 'Device only responds to illegitimate MLDv1 queries even though MLDv2 queries are sent, possibly downgraded', label)
            if row not in existing_rows:
                new_rows.append(dict(zip(['ID', 'MAC', 'Mode', 'IPver', 'Code', 'Description', 'Label'], row)))
                existing_rows.add(row)
        net_rows = [
            ('Network', '', 'a,a+', '6', 'PTV-NET-IDENT-ACTIVE-MLDV1', 'Network allows the delivery of illegitimate MLDv1 queries', '1' if detect_mldv1 else '0'),
            ('Network', '', 'p,a,a+', '6', 'PTV-NET-NET-MISCONF-MLD1GLIP', 'Network allows the delivery of MLDv1 messages from a global address', '1' if detect_mldv1_global else '0'),
            ('Network', '', 'a,a+', '6', 'PTV-NET-IDENT-ACTIVE-MLDV2', 'Network allows the delivery of illegitimate MLDv2 queries', '1' if detect_mldv2 else '0'),
            ('Network', '', 'p,a,a+', '6', 'PTV-NET-NET-MISCONF-MLD2GLIP', 'Network allows the delivery of MLDv2 messages from a global address', '1' if detect_mldv2_global else '0')
        ]
        for row in net_rows:
            if row not in existing_rows:
                new_rows.append(dict(zip(['ID', 'MAC', 'Mode', 'IPver', 'Code', 'Description', 'Label'], row)))
        if new_rows:
            os.makedirs(os.path.dirname(output_file), exist_ok=True)
            write_header = not os.path.exists(output_file)
            with open(output_file, mode='a', newline='') as csvfile:
                fieldnames = ['ID', 'MAC', 'Mode', 'IPver', 'Code', 'Description', 'Label']
                writer = csv.DictWriter(csvfile, fieldnames=fieldnames)
                if write_header:
                    writer.writeheader()
                writer.writerows(new_rows)

    def store_ipv6_vulnerability(self, ip_file=f"{file_path}addresses.csv"):
        """Output: Writes IPv6 predictability vulnerability to CSV. Description: Checks for predictable IPv6 addresses."""
        role_dict = Vulnerability.read_role_node_csv(self.role_file)
        if not isinstance(role_dict, dict) or not role_dict:
            return
        ip_has_data = has_additional_data(ip_file)
        if not ip_has_data:
            return
        mac_ips = {}
        try:
            with open(ip_file, newline='') as csvfile:
                reader = csv.DictReader(csvfile)
                for row in reader:
                    mac = row['MAC'].strip()
                    ip = row['IP'].strip()
                    if mac not in mac_ips:
                        mac_ips[mac] = []
                    mac_ips[mac].append(ip)
        except FileNotFoundError:
            return
        existing_rows = set()
        output_file = self.vulnerability_file
        if os.path.exists(output_file):
            with open(output_file, newline='') as csvfile:
                reader = csv.reader(csvfile)
                next(reader, None)
                for row in reader:
                    if len(row) == 7:
                        row_tuple = tuple(cell.strip() for cell in row[:7])
                        existing_rows.add(row_tuple)
        new_rows = []
        for device_id, mac in role_dict.items():
            label = '0'
            if mac in mac_ips:
                for ip in mac_ips[mac]:
                    if is_valid_ipv6(ip) and is_ipv6_predictable(ip, mac):
                        label = '1'
                        break
            row = (str(device_id), mac, 'p,a,a+', '6', 'PTV-NET-IDENT-PREDICT-GLOBIP', 'Devices uses predictable IPv6 address', label)
            if row not in existing_rows:
                new_rows.append(dict(zip(['ID', 'MAC', 'Mode', 'IPver', 'Code', 'Description', 'Label'], row)))
                existing_rows.add(row)
        if new_rows:
            os.makedirs(os.path.dirname(output_file), exist_ok=True)
            write_header = not os.path.exists(output_file)
            with open(output_file, mode='a', newline='') as csvfile:
                fieldnames = ['ID', 'MAC', 'Mode', 'IPver', 'Code', 'Description', 'Label']
                writer = csv.DictWriter(csvfile, fieldnames=fieldnames)
                if write_header:
                    writer.writeheader()
                writer.writerows(new_rows)

    def store_icmp_vulnerability(self, ipver: IPMode):
        """Output: Writes ICMP vulnerabilities to CSV. Description: Checks for ICMP/ICMPv6 responses and stores device/network results."""
        role_dict = Vulnerability.read_role_node_csv(self.role_file)
        if not isinstance(role_dict, dict) or not role_dict:
            return
        icmp_file = self.time_incoming_file
        icmp_has_data = has_additional_data(icmp_file)
        if not icmp_has_data:
            return
        packet_macs = {}
        try:
            with open(icmp_file, newline='') as csvfile:
                reader = csv.DictReader(csvfile)
                for row in reader:
                    mac = row['MAC'].strip()
                    packet = row['packet'].strip()
                    if mac not in packet_macs:
                        packet_macs[mac] = []
                    packet_macs[mac].append(packet)
        except FileNotFoundError:
            return
        existing_rows = set()
        output_file = self.vulnerability_file
        if os.path.exists(output_file):
            with open(output_file, newline='') as csvfile:
                reader = csv.reader(csvfile)
                next(reader, None)
                for row in reader:
                    if len(row) == 7:
                        row_tuple = tuple(cell.strip() for cell in row[:7])
                        existing_rows.add(row_tuple)
        icmp6types = [
            "Destination unreachable", "Packet too big", "Time exceeded", "Parameter problem",
            "Echo Reply", "Redirect Message",
            "ICMP Node Information Query", "ICMP Node Information Response",
            "Inverse Neighbor Discovery Solicitation Message", "Inverse Neighbor Discovery Advertisement Message",
            "Private Experimentation"
        ]
        new_rows = []
        device_vuln = defaultdict(lambda: {
            'redirect6': False,
            'icmp6_multiecho': {'has_vuln': False, 'responses': []},
            'icmp6_invechodo': {'has_vuln': False, 'responses': []},
            'icmp6_invechohbh': {'has_vuln': False, 'responses': []},
            'icmp6_invpacket': {'has_vuln': False, 'responses': []},
            'redirect': False,
            'icmp_multiecho': False,
            'icmp_brcastecho': False,
            'icmp_invpacket': False
        })
        for device_id, mac in role_dict.items():
            if mac not in packet_macs:
                continue
            for packet in packet_macs[mac]:
                if "type = Redirect" in packet:
                    if ipver.ipv6 and "version = 6" in packet:
                        device_vuln[mac]['redirect6'] = True
                    if ipver.ipv4 and "version = 4" in packet:
                        device_vuln[mac]['redirect'] = True
                if "id = 0x6f" in packet and ipver.ipv6:
                    device_vuln[mac]['icmp6_multiecho']['has_vuln'] = True
                    for key_response in icmp6types:
                        if key_response in packet and key_response not in device_vuln[mac]['icmp6_multiecho']['responses']:
                            device_vuln[mac]['icmp6_multiecho']['responses'].append(key_response)
                if "0x14d" in packet and ipver.ipv6:
                    device_vuln[mac]['icmp6_invechodo']['has_vuln'] = True
                    for key_response in icmp6types:
                        if key_response in packet and key_response not in device_vuln[mac]['icmp6_invechodo']['responses']:
                            device_vuln[mac]['icmp6_invechodo']['responses'].append(key_response)
                if "0x1bc" in packet and ipver.ipv6:
                    device_vuln[mac]['icmp6_invechohbh']['has_vuln'] = True
                    for key_response in icmp6types:
                        if key_response in packet and key_response not in device_vuln[mac]['icmp6_invechohbh']['responses']:
                            device_vuln[mac]['icmp6_invechohbh']['responses'].append(key_response)
                if "Destination Options Header" in packet and "otype = 128" in packet and ipver.ipv6:
                    device_vuln[mac]['icmp6_invpacket']['has_vuln'] = True
                    for key_response in icmp6types:
                        if key_response in packet and key_response not in device_vuln[mac]['icmp6_invpacket']['responses']:
                            device_vuln[mac]['icmp6_invpacket']['responses'].append(key_response)
                if "0x29a" in packet and ipver.ipv4:
                    device_vuln[mac]['icmp_multiecho'] = True
                if "0x309" in packet and ipver.ipv4:
                    device_vuln[mac]['icmp_brcastecho'] = True
                if "type = 255" in packet and ipver.ipv4:
                    device_vuln[mac]['icmp_invpacket'] = True
        for device_id, mac in role_dict.items():
            if ipver.ipv6:
                label = '1' if device_vuln[mac]['redirect6'] else '0'
                row = (str(device_id), mac, 'p,a,a+', '6', 'PTV-NET-MITM-ICMP6REDIRDEV', 'Device communication can be redirected using ICMPv6 Redirect', label)
                if row not in existing_rows:
                    new_rows.append(dict(zip(['ID', 'MAC', 'Mode', 'IPver', 'Code', 'Description', 'Label'], row)))
                    existing_rows.add(row)
                if device_vuln[mac]['icmp6_multiecho']['has_vuln'] and device_vuln[mac]['icmp6_multiecho']['responses']:
                    response_string = ' / '.join(device_vuln[mac]['icmp6_multiecho']['responses'])
                    description = f'Device responds to standard multicast ICMPv6 Echo Request with {response_string} message'
                    label = '1'
                else:
                    description = 'Device responds to standard multicast ICMPv6 Echo Request'
                    label = '0'
                row = (str(device_id), mac, 'p,a,a+', '6', 'PTV-NET-IDENT-ICMP6-MULTIECHODEV', description, label)
                if row not in existing_rows:
                    new_rows.append(dict(zip(['ID', 'MAC', 'Mode', 'IPver', 'Code', 'Description', 'Label'], row)))
                    existing_rows.add(row)
                if device_vuln[mac]['icmp6_invechodo']['has_vuln'] and device_vuln[mac]['icmp6_invechodo']['responses']:
                    response_string = ' / '.join(device_vuln[mac]['icmp6_invechodo']['responses'])
                    description = f'Device responds to invalid Destination Option ICMPv6 Echo Request with {response_string} message'
                    label = '1'
                else:
                    description = 'Device responds to invalid Destination Option ICMPv6 Echo Request'
                    label = '0'
                row = (str(device_id), mac, 'p,a,a+', '6', 'PTV-NET-IDENT-ICMP6-INVECHODODEV', description, label)
                if row not in existing_rows:
                    new_rows.append(dict(zip(['ID', 'MAC', 'Mode', 'IPver', 'Code', 'Description', 'Label'], row)))
                    existing_rows.add(row)
                if device_vuln[mac]['icmp6_invechohbh']['has_vuln'] and device_vuln[mac]['icmp6_invechohbh']['responses']:
                    response_string = ' / '.join(device_vuln[mac]['icmp6_invechohbh']['responses'])
                    description = f'Device responds to invalid Hop-by-Hop ICMPv6 Echo Request with {response_string} message'
                    label = '1'
                else:
                    description = 'Device responds to invalid Hop-by-Hop ICMPv6 Echo Request'
                    label = '0'
                row = (str(device_id), mac, 'p,a,a+', '6', 'PTV-NET-IDENT-ICMP6-INVECHOHBHDEV', description, label)
                if row not in existing_rows:
                    new_rows.append(dict(zip(['ID', 'MAC', 'Mode', 'IPver', 'Code', 'Description', 'Label'], row)))
                    existing_rows.add(row)
                if device_vuln[mac]['icmp6_invpacket']['has_vuln'] and device_vuln[mac]['icmp6_invpacket']['responses']:
                    response_string = ' / '.join(device_vuln[mac]['icmp6_invpacket']['responses'])
                    description = f'Device responds to invalid ICMPv6 packets with {response_string} message'
                    label = '1'
                else:
                    description = 'Device responds to invalid ICMPv6 packets'
                    label = '0'
                row = (str(device_id), mac, 'p,a,a+', '6', 'PTV-NET-IDENT-ICMP6-INVPACKETDEV', description, label)
                if row not in existing_rows:
                    new_rows.append(dict(zip(['ID', 'MAC', 'Mode', 'IPver', 'Code', 'Description', 'Label'], row)))
                    existing_rows.add(row)
            if ipver.ipv4:
                label = '1' if device_vuln[mac]['redirect'] else '0'
                row = (str(device_id), mac, 'p,a,a+', '4', 'PTV-NET-MITM-ICMPREDIRDEV', 'Device communication can be redirected using ICMP Redirect', label)
                if row not in existing_rows:
                    new_rows.append(dict(zip(['ID', 'MAC', 'Mode', 'IPver', 'Code', 'Description', 'Label'], row)))
                    existing_rows.add(row)
                label = '1' if device_vuln[mac]['icmp_multiecho'] else '0'
                row = (str(device_id), mac, 'p,a,a+', '4', 'PTV-NET-IDENT-ICMP-MULTIECHODEV', 'Device responds to standard multicast ICMP Echo Request', label)
                if row not in existing_rows:
                    new_rows.append(dict(zip(['ID', 'MAC', 'Mode', 'IPver', 'Code', 'Description', 'Label'], row)))
                    existing_rows.add(row)
                label = '1' if device_vuln[mac]['icmp_brcastecho'] else '0'
                row = (str(device_id), mac, 'p,a,a+', '4', 'PTV-NET-IDENT-ICMP-BRCASTECHODEV', 'Device responds to standard broadcast ICMP Echo Request', label)
                if row not in existing_rows:
                    new_rows.append(dict(zip(['ID', 'MAC', 'Mode', 'IPver', 'Code', 'Description', 'Label'], row)))
                    existing_rows.add(row)
                label = '1' if device_vuln[mac]['icmp_invpacket'] else '0'
                row = (str(device_id), mac, 'p,a,a+', '4', 'PTV-NET-IDENT-ICMP-INVPACKETDEV', 'Device responds to invalid ICMP packets', label)
                if row not in existing_rows:
                    new_rows.append(dict(zip(['ID', 'MAC', 'Mode', 'IPver', 'Code', 'Description', 'Label'], row)))
                    existing_rows.add(row)
        def net_label(key):
            if isinstance(device_vuln[list(role_dict.values())[0]][key], dict):
                return '1' if any(device_vuln[mac][key]['has_vuln'] for mac in role_dict.values()) else '0'
            else:
                return '1' if any(device_vuln[mac][key] for mac in role_dict.values()) else '0'
        net_rows = [
            ('PTV-NET-MITM-ICMPREDIR', 'Network does not block ICMP Redirect messages', net_label('redirect'), '4'),
            ('PTV-NET-MITM-ICMP6REDIR', 'Network does not block ICMPv6 Redirect messages', net_label('redirect6'), '6'),
            ('PTV-NET-IDENT-ICMP6-MULTIECHO', 'Network allows the delivery of standard multicast ICMPv6 Echo Request', net_label('icmp6_multiecho'), '6'),
            ('PTV-NET-IDENT-ICMP6-INVECHODO', 'Network allows the delivery of invalid Destination Option ICMPv6 Echo Request', net_label('icmp6_invechodo'), '6'),
            ('PTV-NET-IDENT-ICMP6-INVECHOHBH', 'Network allows the delivery of invalid Hop-by-Hop ICMPv6 Echo Request', net_label('icmp6_invechohbh'), '6'),
            ('PTV-NET-IDENT-ICMP6-INVPACKET', 'Network allows the delivery of invalid ICMPv6 packets', net_label('icmp6_invpacket'), '6'),
            ('PTV-NET-IDENT-ICMP-MULTIECHO', 'Network allows the delivery of standard multicast ICMP Echo Request', net_label('icmp_multiecho'), '4'),
            ('PTV-NET-IDENT-ICMP-BRCASTECHO', 'Network allows the delivery of standard broadcast ICMP Echo Request', net_label('icmp_brcastecho'), '4'),
            ('PTV-NET-IDENT-ICMP-INVPACKET', 'Network allows the delivery of invalid ICMP packets', net_label('icmp_invpacket'), '4'),
        ]
        for code, desc, label, version in net_rows:
            row = ('Network', '', 'p,a,a+', version, code, desc, label)
            if row not in existing_rows:
                if (ipver.ipv4 and version == '4') or (ipver.ipv6 and version == '6'):
                    new_rows.append(dict(zip(['ID', 'MAC', 'Mode', 'IPver', 'Code', 'Description', 'Label'], row)))
                    existing_rows.add(row)
        if new_rows:
            unique_rows = {}
            for row in new_rows:
                key = (row['MAC'], row['Code'], row['IPver'])
                if key not in unique_rows:
                    unique_rows[key] = row
                else:
                    current_desc_len = len(row['Description'])
                    existing_desc_len = len(unique_rows[key]['Description'])
                    if current_desc_len > existing_desc_len:
                        unique_rows[key] = row
            filtered_rows = list(unique_rows.values())
            os.makedirs(os.path.dirname(output_file), exist_ok=True)
            write_header = not os.path.exists(output_file)
            with open(output_file, mode='a', newline='') as csvfile:
                fieldnames = ['ID', 'MAC', 'Mode', 'IPver', 'Code', 'Description', 'Label']
                writer = csv.DictWriter(csvfile, fieldnames=fieldnames)
                if write_header:
                    writer.writeheader()
                writer.writerows(filtered_rows)

    def store_ra_vulnerability(self, ra_file=f"{file_path}RA.csv"):
        """Output: Writes RA vulnerabilities to CSV. Description: Checks for fraudulent RA/DNS and stores device/network results."""
        def extract_ipv6_dst(text):
            matches = re.findall(r'dst\s*=\s*([a-fA-F0-9:]+)', text)
            for match in matches:
                if ':' in match and not re.match(r'^([0-9A-Fa-f]{2}:){5}[0-9A-Fa-f]{2}$', match):
                    return match
            return None
        def extract_ipv6_src(text):
            matches = re.findall(r'src\s*=\s*([a-fA-F0-9:]+)', text)
            for match in matches:
                if ':' in match and not re.match(r'^([0-9A-Fa-f]{2}:){5}[0-9A-Fa-f]{2}$', match):
                    return match
            return None
        try:
            role_dict = Vulnerability.read_role_node_csv(self.role_file)
            if not isinstance(role_dict, dict) or not role_dict:
                return
        except Exception:
            return
        if not has_additional_data(ra_file):
            return
        mac_preferences = {}
        try:
            with open(ra_file, 'r', newline='') as csvfile:
                reader = csv.DictReader(csvfile)
                required_columns = ['MAC', 'DNS', 'M', 'O', 'Preference']
                if not all(col in reader.fieldnames for col in required_columns):
                    return
                for row in reader:
                    mac = row['MAC'].strip()
                    mac_preferences[mac] = row['Preference'].strip()
        except FileNotFoundError:
            return
        except Exception:
            return
        mac_packets = {}
        try:
            with open(self.time_incoming_file, 'r', newline='') as csvfile:
                reader = csv.DictReader(csvfile)
                required_columns = ['MAC', 'packet']
                if not all(col in reader.fieldnames for col in required_columns):
                    return
                for row in reader:
                    mac = row['MAC'].strip()
                    packet = row['packet'].strip()
                    if mac not in mac_packets:
                        mac_packets[mac] = []
                    mac_packets[mac].append(packet)
        except FileNotFoundError:
            return
        except Exception:
            return
        existing_rows = set()
        output_file = self.vulnerability_file
        if os.path.exists(output_file):
            try:
                with open(output_file, 'r', newline='') as csvfile:
                    reader = csv.reader(csvfile)
                    next(reader, None)
                    for row in reader:
                        if len(row) == 7:
                            row_tuple = tuple(cell.strip() for cell in row[:7])
                            existing_rows.add(row_tuple)
            except Exception:
                return
        new_rows = []
        detect_fakeradns = False
        detect_raguard = False
        detect_fakera = False
        for device_number, mac in role_dict.items():
            has_fakeradns = False
            has_fakera = False
            has_raguard = False
            if self.dns is not None:
                for dns_ip in self.dns:
                    if is_valid_ipv6(dns_ip):
                        for packet in mac_packets.get(mac, []):
                            if f"dst = {dns_ip}" in packet:
                                detect_fakeradns = True
                                detect_fakera = True
                                detect_raguard = True
                                has_fakeradns = True
                                has_fakera = True
                                has_raguard = True
                                break
                row1 = (
                    str(device_number),
                    mac, 'a+', '6',
                    'PTV-NET-MITM-FAKERADNSDEV',
                    'Device connects to a fraudulent DNS server through a spoofed RA message',
                    '1' if has_fakeradns else '0'
                )
                if row1 not in existing_rows:
                    new_rows.append(dict(zip(['ID', 'MAC', 'Mode', 'IPver', 'Code', 'Description', 'Label'], row1)))
                    existing_rows.add(row1)
                row2 = (
                    str(device_number),
                    mac, 'a+', '6',
                    'PTV-NET-NET-MISCONF-FAKERADEV',
                    'Device does not ignore the illegitimate RA packets',
                    '1' if has_fakera else '0'
                )
                if row2 not in existing_rows:
                    new_rows.append(dict(zip(['ID', 'MAC', 'Mode', 'IPver', 'Code', 'Description', 'Label'], row2)))
                    existing_rows.add(row2)
        device_fakera = defaultdict(lambda: False)
        with open(self.time_incoming_file, 'r', newline='') as time_file:
            time_reader = csv.reader(time_file)
            time_header = next(time_reader)
            src_mac_index = time_header.index('MAC')
            packet_index = time_header.index('packet')
            for row in time_reader:
                if f"dst = {self.smac}" in row[packet_index]:
                    dst_ip = extract_ipv6_dst(row[packet_index])
                    if dst_ip is not None and is_global_unicast_ipv6(dst_ip) and dst_ip not in Interface(self.interface).get_interface_ipv6_ips():
                        detect_fakera = True
                        detect_raguard = True
                        device_fakera[row[src_mac_index]] = True
                if self.network:
                    if check_ipv6_addresses_generated_from_prefix(extract_ipv6_src(row[packet_index]), f"{self.network}/{self.prefix_len}"):
                        detect_fakera = True
                        detect_raguard = True
                        device_fakera[row[src_mac_index]] = True
        for device_number, mac in role_dict.items():
            label = '1' if device_fakera[mac] else '0'
            row = (
                str(device_number),
                mac, 'a+', '6',
                'PTV-NET-NET-MISCONF-FAKERADEV',
                'Device does not ignore the illegitimate RA packets',
                label
            )
            if row not in existing_rows:
                new_rows.append(dict(zip(['ID', 'MAC', 'Mode', 'IPver', 'Code', 'Description', 'Label'], row)))
                existing_rows.add(row)
        net_rows = [
            (
                'Network',
                '', 'a+', '6',
                'PTV-NET-MITM-FAKERADNS',
                'Network allows a client to be forced to use a fraudulent DNS server through a spoofed RA message',
                '1' if detect_fakeradns else '0'
            ),
            (
                'Network',
                '', 'a+', '6',
                'PTV-NET-MISCONF-RAGUARD',
                'Network does not have RA guard configured',
                '1' if detect_raguard else '0'
            ),
            (
                'Network',
                '', 'a+', '6',
                'PTV-NET-NET-MISCONF-FAKERA',
                'Network allows the delivery of illegitimate RA packets',
                '1' if detect_fakera else '0'
            )
        ]
        for row in net_rows:
            if row not in existing_rows:
                new_rows.append(dict(zip(['ID', 'MAC', 'Mode', 'IPver', 'Code', 'Description', 'Label'], row)))
        if new_rows:
            try:
                os.makedirs(os.path.dirname(output_file), exist_ok=True)
                write_header = not os.path.exists(output_file)
                with open(output_file, 'a', newline='') as csvfile:
                    fieldnames = ['ID', 'MAC', 'Mode', 'IPver', 'Code', 'Description', 'Label']
                    writer = csv.DictWriter(csvfile, fieldnames=fieldnames)
                    if write_header:
                        writer.writeheader()
                    writer.writerows(new_rows)
            except Exception:
                return
